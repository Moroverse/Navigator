{"kind":"article","schemaVersion":{"minor":3,"patch":0,"major":0},"metadata":{"modules":[{"name":"Navigator"}],"roleHeading":"Article","title":"Advanced Destinations","role":"article"},"variants":[{"paths":["\/documentation\/navigator\/advanceddestinations"],"traits":[{"interfaceLanguage":"swift"}]}],"primaryContentSections":[{"kind":"content","content":[{"anchor":"External-NavigationDestinations","text":"External NavigationDestinations","type":"heading","level":2},{"type":"paragraph","inlineContent":[{"type":"text","text":"Earlier we demonstrated how to provide "},{"type":"reference","isActive":true,"identifier":"doc:\/\/Navigator\/documentation\/Navigator\/NavigationDestination"},{"text":" types with a variable that returns the correct view for that type.","type":"text"}]},{"code":["extension HomeDestinations: NavigationDestination {","    public var view: some View {","        switch self {","        case .page2:","            HomePage2View()","        case .page3:","            HomePage3View()","        ...","        }","    }","}"],"type":"codeListing","syntax":"swift"},{"inlineContent":[{"text":"It’s a powerful technique, but what if we can’t construct a specific view without external dependencies or without accessing the environment?","type":"text"}],"type":"paragraph"},{"anchor":"Destination-Views","type":"heading","text":"Destination Views","level":3},{"inlineContent":[{"type":"text","text":"Simple. Just delegate the view building to a standard SwiftUI view!"}],"type":"paragraph"},{"code":["extension HomeDestinations: NavigationDestination {","    public var view: some View {","        HomeDestinationsView(destination: self)","    }","}","","private struct HomeDestinationsView: View {","    let destination: HomeDestinations","    @Environment(\\.homeDependencies) var resolver","    var body: some View {","        switch self {","        case .home:","            HomePageView(viewModel: HomePageViewModel(dependencies: resolver))","        case .page2:","            HomePage2View(viewModel: HomePage2ViewModel(dependencies: resolver))","        case .page3:","            HomePage3View(viewModel: HomePage3ViewModel(dependencies: resolver))","        case .pageN(let value):","            HomePageNView(dependencies: resolver, number: value)","        case .external:","            resolver.externalView()","        }","    }","}"],"syntax":"swift","type":"codeListing"},{"type":"paragraph","inlineContent":[{"type":"text","text":"In the above code, we obtain a "},{"type":"codeVoice","code":"homeDependencies"},{"type":"text","text":" resolver from the environment and then use it to construct our views"},{"type":"text","text":" "},{"type":"text","text":"and view models."}]},{"text":"Passing Dependencies","level":3,"type":"heading","anchor":"Passing-Dependencies"},{"inlineContent":[{"type":"text","text":"Note that some of the examples expose the view model to the caller, and that’s a practice I would generally argue against. The fact that a view has a view model (or not) is an implementation detail and should be private to the view itself."}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"Further, exposing the view model and its requirements complicates the call sites and really just kicks the can down the road. Sure, my VM gets its dependencies injected, but how does the "},{"type":"emphasis","inlineContent":[{"text":"caller","type":"text"}]},{"text":" get them to inject?","type":"text"}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"type":"text","text":"But creating a "},{"type":"emphasis","inlineContent":[{"type":"text","text":"private"}]},{"type":"text","text":" destination view means that external dependency is never exposed to the outside world… and that tends to mitigate the problem in my book."}]},{"type":"codeListing","syntax":"swift","code":["case .page2:","    HomePage2View(viewModel: HomePage2ViewModel(dependencies: resolver))"]},{"type":"paragraph","inlineContent":[{"text":"Sites specify the desired view using its enumerated value, but they never see the actual view, nor are they concerned with its requirements.","type":"text"}]},{"inlineContent":[{"text":"Alternatively, one could simply pass our environment-based dependency resolver to the view and let the view handle it as needed.","type":"text"}],"type":"paragraph"},{"syntax":"swift","code":["case .pageN(let value):","    HomePageNView(dependencies: resolver, number: value)","","struct HomePageNView: View {","    @StateObject private var viewModel: HomePageNViewModel","    init(dependencies: HomeDependencies, number: Int) {","        self._viewModel = .init(wrappedValue: .init(dependencies: dependencies, number: number))","    }","    var body: some View {","        ...","    }","}"],"type":"codeListing"},{"type":"paragraph","inlineContent":[{"type":"emphasis","inlineContent":[{"text":"See the ‘DemoDependency.swift’ file in the NavigatorDemo project for a possible dependency injection mechanism.","type":"text"}]}]},{"anchor":"NavigationDestinations-within-Views","type":"heading","level":2,"text":"NavigationDestinations within Views"},{"inlineContent":[{"type":"text","text":"This technique also allows us to construct and use fully functional views elsewhere in our view code. Consider."}],"type":"paragraph"},{"type":"codeListing","syntax":"swift","code":["struct RootHomeView: View {","    var body: some View {","        ManagedNavigationStack {","            HomeDestinations.home()","                .navigationDestination(HomeDestinations.self)","        }","    }","}"]},{"inlineContent":[{"type":"text","text":"Calling the destination enumeration as a factory function obtains a fully resolved "},{"type":"codeVoice","code":"HomePageView"},{"type":"text","text":" and view model from "},{"type":"codeVoice","code":"HomeDestinationsView"},{"type":"text","text":","},{"text":" ","type":"text"},{"type":"text","text":"complete and ready to go."}],"type":"paragraph"},{"type":"heading","level":2,"anchor":"Custom-Sheets-using-NavigationDestination","text":"Custom Sheets using NavigationDestination"},{"type":"paragraph","inlineContent":[{"text":"Let’s demonstrate that again using a custom presentation mechanism with detents.","type":"text"}]},{"inlineContent":[{"type":"text","text":"Only this time instead of evaluating the enumerated value directly we’ll do the same using a destination variable."}],"type":"paragraph"},{"type":"codeListing","syntax":"swift","code":["struct CustomSheetView: View {","    @State private var showSettings: SettingsDestinations?","    var body: some View {","        List {","            Button(\"Present Page 2 via Sheet\") {","                showSettings = .page2","            }","            Button(\"Present Page 3 via Sheet\") {","                showSettings = .page3","            }","            .sheet(item: $showSettings) { destination in","                destination() \/\/ obtain view","                    .presentationDetents([.medium, .large])","                    .presentationDragIndicator(.visible)","                    .navigationDismissible()","            }","        }","    }","}"]},{"type":"paragraph","inlineContent":[{"text":"Setting the variable passes the desired destination to the sheet closure via the ","type":"text"},{"type":"codeVoice","code":"$showSettings"},{"text":" binding. Which again allows us to directly evaluate the value and obtain a fully resolved view ready for presentation.","type":"text"}]},{"type":"heading","anchor":"Cross-Module-View-Dependencies","level":2,"text":"Cross Module View Dependencies"},{"inlineContent":[{"type":"text","text":"Another technique that might not be apparent and you might have missed at first glance is how this gives us the ability to pass required views across features."}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Take another look at our "},{"type":"codeVoice","code":"HomeDestinationsView"},{"type":"text","text":"."}]},{"type":"codeListing","syntax":"swift","code":["private struct HomeDestinationsView: View {","    let destination: HomeDestinations","    @Environment(\\.homeDependencies) var resolver","    var body: some View {","        switch self {","        ...","        case .external:","            resolver.externalView()","        }","    }","}"]},{"inlineContent":[{"text":"Note how our feature get an externally provided view from our dependency resolver.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"text":"The Home feature doesn’t know what module or feature provided the view. Nor should it care. It just knows that it needs it and that its up to ","type":"text"},{"code":"HomeDependencies","type":"codeVoice"},{"type":"text","text":" to provide it."}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"The application, however, sees all, knows all, and can provide the missing cross-module dependency."}],"type":"paragraph"},{"code":["typealias AppDependencies = CoreDependencies","    & HomeDependencies","    & SettingsDependencies","","class AppResolver: AppDependencies {","    ...","    @MainActor func externalView() -> AnyView {","        \/\/ reach out to the settings module to provide the view needed","        SettingsDestinations.external.asAnyView()","    }","    ...","}"],"type":"codeListing","syntax":"swift"},{"inlineContent":[{"type":"text","text":"Have I mentioned how powerful this technique is?"}],"type":"paragraph"}]}],"sections":[],"identifier":{"interfaceLanguage":"swift","url":"doc:\/\/Navigator\/documentation\/Navigator\/AdvancedDestinations"},"abstract":[{"text":"Building NavigationDestinations that access the environment and other use cases","type":"text"}],"hierarchy":{"paths":[["doc:\/\/Navigator\/documentation\/Navigator"]]},"seeAlsoSections":[{"title":"Related Documentation","identifiers":["doc:\/\/Navigator\/documentation\/Navigator\/Destinations"],"anchor":"Related-Documentation"}],"references":{"doc://Navigator/documentation/Navigator/NavigationDestination":{"abstract":[{"text":"Provides enumerated navigation types than can be translated into Views.","type":"text"}],"title":"NavigationDestination","role":"symbol","url":"\/documentation\/navigator\/navigationdestination","fragments":[{"text":"protocol","kind":"keyword"},{"kind":"text","text":" "},{"text":"NavigationDestination","kind":"identifier"}],"navigatorTitle":[{"kind":"identifier","text":"NavigationDestination"}],"identifier":"doc:\/\/Navigator\/documentation\/Navigator\/NavigationDestination","kind":"symbol","type":"topic"},"doc://Navigator/documentation/Navigator":{"identifier":"doc:\/\/Navigator\/documentation\/Navigator","abstract":[{"type":"text","text":"Managed NavigationStacks for SwiftUI."}],"url":"\/documentation\/navigator","title":"Navigator","kind":"symbol","role":"collection","type":"topic"},"doc://Navigator/documentation/Navigator/Destinations":{"title":"Destinations","type":"topic","role":"article","abstract":[{"text":"All navigation in Navigator is accomplished using enumerated values that conform to the NavigationDestination protocol.","type":"text"}],"kind":"article","identifier":"doc:\/\/Navigator\/documentation\/Navigator\/Destinations","url":"\/documentation\/navigator\/destinations"}}}